{
  "id": "7721b9ad-aa52-4ec5-9f2f-afc1b510fb94",
  "name": "Inventory Detail",
  "template": "grid-advanced",
  "owner": "brian_johnson@mkdiamond.com",
  "shares": [
  ],
  "vars": [
    {
      "name": "data",
      "value": "[]"
    },
    {
      "name": "dataIterator",
      "value": "[]"
    },
    {
      "name": "config",
      "value": "{\"description\":\"Advanced Grid\",\"icon\":\"fa-table\",\"refreshing\":\"false\",\"ref\":\"5ed85f27-f8e1-e9f9-f1c1\",\"showAll\":false,\"summaryTypes\":[{\"type\":\"first\",\"caption\":\"First\"},{\"type\":\"last\",\"caption\":\"Last\"},{\"type\":\"count\",\"caption\":\"Count\"},{\"type\":\"min\",\"caption\":\"Min\"},{\"type\":\"max\",\"caption\":\"Max\"},{\"type\":\"extent\",\"caption\":\"Extent\"},{\"type\":\"sum\",\"caption\":\"Sum\"},{\"type\":\"mean\",\"caption\":\"Mean\"},{\"type\":\"median\",\"caption\":\"Median\"},{\"type\":\"variance\",\"caption\":\"Variance\"},{\"type\":\"deviation\",\"caption\":\"Deviation\"}],\"formatters\":[{\"type\":\"\",\"caption\":\"None\"},{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},{\"type\":\"date\",\"caption\":\"Date\",\"parameters\":[{\"parameterName\":\"format\",\"caption\":\"Format\",\"type\":\"string\",\"value\":\"yMd\"}]},{\"type\":\"number\",\"caption\":\"Number\",\"parameters\":[{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"0\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"3\"}]},{\"type\":\"percent\",\"caption\":\"Percent\",\"parameters\":[{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"0\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"3\"}]}],\"outputFormula\":\"bezl.vars.data = d3.nest().key(function(d) { return d.PartWhse_WarehouseCode; }).key(function(d) { return d.Part_ClassID; }).entries(bezl.data.datasub0);\",\"structure\":[{\"sequence\":1,\"type\":\"group\",\"caption\":\"PartWhse_WarehouseCode Grouping:\",\"groupField\":\"PartWhse_WarehouseCode\",\"summaryOperation\":\"first\",\"columns\":[{\"columnId\":\"0659be26-0f52-416d-eeed\",\"columnName\":\"PartWhse_WarehouseCode\",\"columnHeading\":\"Warehouse Code\",\"columnSize\":2,\"columnPosition\":1,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"1fb86740-f498-25c5-e73c\",\"columnName\":\"Calculated_Total_Cost\",\"columnHeading\":\"Total Part Cost\",\"columnSize\":1,\"columnPosition\":3,\"formatter\":{\"type\":\"currency\",\"obj\":{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},\"currencyCode\":\"USD\",\"temp-currencyCode\":\"USD\",\"symbolDisplay\":\"true\",\"minIntegerDigits\":\"1\",\"minFractionDigits\":\"2\",\"maxFractionDigits\":\"2\"},\"sort\":\"\",\"summaryOperation\":\"sum\"}]},{\"sequence\":2,\"type\":\"group\",\"caption\":\"Part_ClassID Grouping:\",\"groupField\":\"Part_ClassID\",\"summaryOperation\":\"first\",\"columns\":[{\"columnId\":\"4e0cd5eb-916e-f913-424e\",\"columnName\":\"Part_ClassID\",\"columnHeading\":\"Part Class\",\"columnSize\":1,\"columnPosition\":1,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"2289bd97-ef2e-c775-aa64\",\"columnName\":\"Calculated_Total_Cost\",\"columnHeading\":\"Total Part Cost\",\"columnSize\":1,\"columnPosition\":3,\"formatter\":{\"type\":\"currency\",\"obj\":{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},\"currencyCode\":\"USD\",\"temp-currencyCode\":\"USD\",\"symbolDisplay\":\"true\",\"minIntegerDigits\":\"1\",\"minFractionDigits\":\"2\",\"maxFractionDigits\":\"2\"},\"sort\":\"\",\"summaryOperation\":\"sum\"}]},{\"sequence\":3,\"type\":\"detail\",\"caption\":\"Details:\",\"groupField\":\"\",\"summaryOperation\":\"\",\"columns\":[{\"columnId\":\"60af9305-10c1-989e-afeb\",\"columnName\":\"Part_ClassID\",\"columnHeading\":\"Part Class\",\"columnSize\":1,\"columnPosition\":1,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"ff312352-b282-ca95-b77d\",\"columnName\":\"Part_PartNum\",\"columnHeading\":\"Part Num\",\"columnSize\":1,\"columnPosition\":2,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"d39dae35-f6cc-aa83-bfc8\",\"columnName\":\"Part_PartDescription\",\"columnHeading\":\"Part Description\",\"columnSize\":2,\"columnPosition\":3,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"ddcf36f5-f88b-d771-ff52\",\"columnName\":\"Part_UnitPrice\",\"columnHeading\":\"Unit Price\",\"columnSize\":1,\"columnPosition\":4,\"formatter\":{\"type\":\"currency\",\"obj\":{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},\"currencyCode\":\"USD\",\"temp-currencyCode\":\"USD\",\"symbolDisplay\":\"true\",\"minIntegerDigits\":\"1\",\"minFractionDigits\":\"2\",\"maxFractionDigits\":\"2\"},\"sort\":\"\"},{\"columnId\":\"11790c64-3d79-3913-0fd9\",\"columnName\":\"PartWhse_OnHandQty\",\"columnHeading\":\"On Hand Qty\",\"columnSize\":1,\"columnPosition\":5,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"89e553cb-d17b-98f7-554d\",\"columnName\":\"PartWhse_WarehouseCode\",\"columnHeading\":\"Warehouse Code\",\"columnSize\":1,\"columnPosition\":6,\"formatter\":{\"type\":\"\",\"obj\":{\"parameters\":[]}},\"sort\":\"\"},{\"columnId\":\"7d2335cc-1c52-5f37-043d\",\"columnName\":\"Calculated_Cost\",\"columnHeading\":\"Part Cost\",\"columnSize\":1,\"columnPosition\":7,\"formatter\":{\"type\":\"currency\",\"obj\":{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},\"currencyCode\":\"USD\",\"temp-currencyCode\":\"USD\",\"symbolDisplay\":\"true\",\"minIntegerDigits\":\"1\",\"minFractionDigits\":\"2\",\"maxFractionDigits\":\"2\"},\"sort\":\"\"},{\"columnId\":\"f04492dd-202c-3d36-91d2\",\"columnName\":\"Calculated_Total_Cost\",\"columnHeading\":\"Total Part Cost\",\"columnSize\":1,\"columnPosition\":8,\"formatter\":{\"type\":\"currency\",\"obj\":{\"type\":\"currency\",\"caption\":\"Currency\",\"parameters\":[{\"parameterName\":\"currencyCode\",\"caption\":\"Currency Code\",\"type\":\"string\",\"value\":\"USD\"},{\"parameterName\":\"symbolDisplay\",\"caption\":\"Use Symbol?\",\"type\":\"boolean\",\"value\":\"true\"},{\"parameterName\":\"minIntegerDigits\",\"caption\":\"Min Integer Digits\",\"type\":\"number\",\"value\":\"1\"},{\"parameterName\":\"minFractionDigits\",\"caption\":\"Min Fraction Digits\",\"type\":\"number\",\"value\":\"2\"},{\"parameterName\":\"maxFractionDigits\",\"caption\":\"Max Fraction Digits\",\"type\":\"number\",\"value\":\"2\"}]},\"currencyCode\":\"USD\",\"temp-currencyCode\":\"USD\",\"symbolDisplay\":\"true\",\"minIntegerDigits\":\"1\",\"minFractionDigits\":\"2\",\"maxFractionDigits\":\"2\"},\"sort\":\"\"}]}]}"
    }
  ],
  "dataSubscriptions": [
    {
      "onDemand": null,
      "name": "datasub0",
      "connectionId": "cbf62688-75e2-4a99-9426-b8ad8feeb38f",
      "dataSource": "brdb",
      "plugin": "SQLServer",
      "method": "ExecuteQuery",
      "args": "{\"Context\":\"Queries\",\"Connection\":\"EpicorLive10\",\"QueryName\":\"inventoryCost\"}",
      "data": null,
      "refreshInverval": 0,
      "lastRefresh": null
    }
  ],
  "markup": [
    "<label class=\"pull-right\" [hidden]=\"!bezl.vars['config'].refreshing\">Loading... <i class=\"fa fa-spinner fa-spin\" style=\"font-size:24px\"></i></label>",
    "<button (click)=\"bezl.functions['refresh']()\" class=\"btn btn-md btn-primary pull-right\" *ngIf=\"!bezl.vars['config'].refreshing\">Refresh</button>",
    "<div class=\"row\">",
    "<table style=\"width: 100%\" class=\"table table-striped\">",
    "    <tbody>",
    "        <!-- Start off by showing the top level column headers -->",
    "        <template ngFor let-s [ngForOf]=\"bezl.vars['config'].structure\" let-i=\"index\">",
    "            <tr *ngIf=\"i == 0\" style=\"background-color: white\">",
    "                <td  *ngIf=\"s.columns.length > 0 || s.type=='group'\">",
    "                    <div class=\"row\" style=\"padding: 0px\">",
    "                        ",
    "                        <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                            *ngFor=\"let c of s.columns\"",
    "                            style=\"padding-left: 0px; padding-right: 0px;\">",
    "                            ",
    "                            <div style=\"width: 100%;text-align: center;\">",
    "                                <button type=\"button\" ",
    "                                        class=\"btn btn-default\"",
    "                                        style=\"background-color:white; width: 100%\"",
    "                                        (click)=\"bezl.functions['sort']( { section: s, column: c, sequence: 1, initial: false } )\">",
    "                                    <span>{{c.columnHeading}}</span>",
    "                                    <i class=\"fa fa-sort-numeric-asc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'ascending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-numeric-desc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'descending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-alpha-asc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'ascending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                    <i class=\"fa fa-sort-alpha-desc pull-right\" aria-hidden=\"true\" ",
    "                                        *ngIf=\"c.sort == 'descending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                </button>",
    "                            </div>",
    "                        </div>",
    "                    </div> ",
    "                </td>",
    "            </tr>",
    "        </template>",
    "",
    "        <!-- Now begin looping through the entire data structure to construct our layout -->",
    "        <template ngFor let-d [ngForOf]=\"bezl.vars['dataIterator']\" let-i=\"index\">",
    "            <tr *ngIf=\"d.sequence == 1 || d.show\" [ngStyle]=\"{'background-color': (d.selected) ? '#F7B64B' : ''}\">",
    "                <td>",
    "                    <div class=\"row\" style=\"padding: 0px\"",
    "                        (click)=\"bezl.functions['selectRow'](d)\">",
    "                        <!-- Output the data in appropriate columns -->",
    "                        <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                            *ngFor=\"let c of d.columns\"",
    "                            [ngStyle]=\"{'margin-left.px': ((c.columnPosition == 1) ? (d.sequence - 1) * 40 : 0)}\">",
    "                                <div *ngIf=\"d.type == 'group' && c.columnPosition == 1\" class=\"col-sm-1\" style=\"padding-right: 20px\">",
    "                                    <i class=\"fa fa-chevron-right\" aria-hidden=\"true\" *ngIf=\"!d.selected\"></i>",
    "                                    <i class=\"fa fa-chevron-down\" aria-hidden=\"true\" *ngIf=\"d.selected\"></i>",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'currency'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | currency:c.formatter.currencyCode:c.formatter.symbolDisplay:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'percent'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | percent:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div *ngIf=\"c.formatter.type == 'date'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | date:c.formatter.format}}",
    "                                </div>",
    "",
    "                                <div align=\"right\" *ngIf=\"c.formatter.type == 'number'\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName]) | number:(c.formatter.minIntegerDigits || '1') + ",
    "                                                            '.' + (c.formatter.minFractionDigits || '0') + ",
    "                                                            '-' + (c.formatter.maxFractionDigits || '1')}}",
    "                                </div>",
    "",
    "                                <div *ngIf=\"c.formatter.type == ''\">",
    "                                    {{(d.data[c.columnId] || d.data[c.columnName])}}",
    "                                </div>",
    "                        </div>",
    "                    </div> ",
    "",
    "                </td>",
    "            </tr>",
    "",
    "            <!-- Add column headings if this is a grouping -->",
    "            <template ngFor let-s [ngForOf]=\"bezl.vars['config'].structure\">",
    "                <tr *ngIf=\"s.sequence == d.sequence + 1 && d.selected\" style=\"background-color: white\">",
    "                    <td  *ngIf=\"s.columns.length > 0\">",
    "                        <div class=\"row\" style=\"padding: 0px\">                                                                    ",
    "                            <div [ngClass]=\"'col-sm-' + c.columnSize\"",
    "                                *ngFor=\"let c of s.columns\"",
    "                                style=\"padding-left: 0px; padding-right: 0px;\"",
    "                                [ngStyle]=\"{'margin-left.px': ((c.columnPosition == 1) ? (s.sequence - 1) * 40 : 0)}\">",
    "                                ",
    "                                <div style=\"width: 100%;text-align: center;\">",
    "                                    <button type=\"button\" ",
    "                                            class=\"btn btn-default\"",
    "                                            style=\"background-color:white; width: 100%\"",
    "                                            (click)=\"bezl.functions['sort']( { section: s, column: c, sequence: s.sequence, initial: false } )\">",
    "                                        <span>{{c.columnHeading}}</span>",
    "                                        <i class=\"fa fa-sort-numeric-asc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'ascending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-numeric-desc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'descending' && (c.formatter.type == 'currency' || c.formatter.type == 'number' || c.formatter.type == 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-alpha-asc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'ascending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                        <i class=\"fa fa-sort-alpha-desc pull-right\" aria-hidden=\"true\" ",
    "                                            *ngIf=\"c.sort == 'descending' && (c.formatter.type != 'currency' && c.formatter.type != 'number' && c.formatter.type != 'percent')\"></i>",
    "                                    </button>",
    "                                </div>",
    "                            </div>",
    "                        </div> ",
    "                    </td>",
    "                </tr>",
    "            </template>",
    "        </template>",
    "    </tbody>",
    "</table>",
    "</div>"
  ],
  "functions": [
    {
      "method": "ngOnInit",
      "code": "bezl.vars['config'].refreshing = true;",
      "declares": [],
      "compiled": "bezl.vars['config'].refreshing = true;"
    },
    {
      "method": "onDataChange",
      "code": "bezl.data = dataResp;\nif (bezl.data.datasub0 != null && bezl.data.datasub0.length > 0) {\n    bezl.functions['regenerateOutput']();\n    bezl.vars['config'].refreshing = false;\n}",
      "declares": [],
      "compiled": "bezl.data = dataResp;\r\nif (bezl.data.datasub0 != null && bezl.data.datasub0.length > 0) {\r\n bezl.functions['regenerateOutput']();\r\n bezl.vars['config'].refreshing = false;\r\n}\r\n"
    },
    {
      "method": "refresh",
      "code": "bezl.vars['config'].refreshing = true;\nbezl.dataService.process('datasub0');",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "bezl.vars['config'].refreshing = true;\r\n\r\nbezl.dataService.process('datasub0');\r\n"
    },
    {
      "method": "regenerateOutput",
      "code": "eval(bezl.vars['config'].outputFormula);\n\n// This function will be used to \"flatten\" out the values when multiple levels of grouping were\n// used\nvar rollupValues = function(obj, returnValues) {\n  obj.forEach(o => {\n    if (o.values) {\n      rollupValues(o.values, returnValues);\n    } else {\n      returnValues.push(o);\n    }\n  });\n}\n\n// Now add in each of the summarized fields at each group level\n// obj:           This is the actual property we are evaluating.  It starts off as the entire\n//                data object and then crawls through each values sub object.\n// sequence:      This helps us to marry up which piece of the data object we are looking\n//                at as compared to the structure object.  This is incremented by 1 for each\n//                level deeper we go.\n// config:        A reference to the config object.  Does not change in the process,\n//                simply needed as a reference since the recursive function is out of scope.\n// parentUid:     A reference to the parent object UID.\n// dataIterator:  A reference to the dataIterator object we are populating.\nvar processValues = function(obj, sequence, config, parentUid, dataIterator) {\n  var s = config.structure.find(s => s.sequence == sequence);\n\n  if (obj.length > 0 && obj[0].values && obj[0].values.length > 0)\n  {\n    obj.forEach(o => {\n      o.sequence = sequence;\n      o.uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n                  var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n                  return v.toString(16);\n              });\n      var nextIsGroup = config.structure.find(s => s.sequence == sequence + 1 && s.type == 'group');\n\n      var values = [];\n      if (nextIsGroup) {\n        rollupValues(o.values, values);\n      } else {\n        values = o.values;\n      }\n\n      dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid, uid: o.uid });\n\n      s.columns.forEach(col => {\n        switch (col.summaryOperation) {\n            case 'first':\n                o[col.columnId] = values[0][col.columnName];\n                break;\n            case 'last':\n                o[col.columnId] = values[o.values.length - 1][col.columnName];\n                break;\n            case 'count':\n                o[col.columnId] = values.length;\n                break;\n            case 'min':\n                o[col.columnId] = d3.min(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'max':\n                o[col.columnId] = d3.max(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'extent':\n                o[col.columnId] = d3.extent(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'sum':\n                o[col.columnId] = d3.sum(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'mean':\n                o[col.columnId] = d3.mean(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'median':\n                o[col.columnId] = d3.median(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'variance':\n                o[col.columnId] = d3.variance(values, function (d) { return d[col.columnName]; });\n                break;\n            case 'deviation':\n                o[col.columnId] = d3.deviation(values, function (d) { return d[col.columnName]; });\n                break;\n            default:\n                o[col.columnId] = values[0][col.columnName];\n                break;\n        }\n      });\n\n      processValues(o.values, sequence + 1, config, o.uid, dataIterator);\n    });\n  } else {\n    obj.forEach(o => {\n      o.sequence = sequence;\n        dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid });\n    });\n  }\n};\n\n// Use a temp object for processing the data that we point back to\n// when done to trigger Angular change detection\nvar tempData = bezl.vars['data'];\nbezl.vars['dataIterator'] = [];\nprocessValues(tempData, 1, bezl.vars['config'], '', bezl.vars['dataIterator']);\nbezl.vars['data'] = tempData;\n\n// Apply sorts\nbezl.vars['config'].structure.forEach(s => {\n  s.columns.forEach(c => {\n    if (c.sort != '') {\n      bezl.functions['sort']( { section: s, column: c, sequence: s.sequence, initial: true });\n    }\n  });\n});",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts",
        "d3"
      ],
      "compiled": "eval(bezl.vars['config'].outputFormula);\r\n// This function will be used to \"flatten\" out the values when multiple levels of grouping were\r\n// used\r\nvar rollupValues = function (obj, returnValues) {\r\n obj.forEach(function (o) {\r\n if (o.values) {\r\n rollupValues(o.values, returnValues);\r\n }\r\n else {\r\n returnValues.push(o);\r\n }\r\n });\r\n};\r\n// Now add in each of the summarized fields at each group level\r\n// obj: This is the actual property we are evaluating. It starts off as the entire\r\n// data object and then crawls through each values sub object.\r\n// sequence: This helps us to marry up which piece of the data object we are looking\r\n// at as compared to the structure object. This is incremented by 1 for each\r\n// level deeper we go.\r\n// config: A reference to the config object. Does not change in the process,\r\n// simply needed as a reference since the recursive function is out of scope.\r\n// parentUid: A reference to the parent object UID.\r\n// dataIterator: A reference to the dataIterator object we are populating.\r\nvar processValues = function (obj, sequence, config, parentUid, dataIterator) {\r\n var s = config.structure.find(function (s) { return s.sequence == sequence; });\r\n if (obj.length > 0 && obj[0].values && obj[0].values.length > 0) {\r\n obj.forEach(function (o) {\r\n o.sequence = sequence;\r\n o.uid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n return v.toString(16);\r\n });\r\n var nextIsGroup = config.structure.find(function (s) { return s.sequence == sequence + 1 && s.type == 'group'; });\r\n var values = [];\r\n if (nextIsGroup) {\r\n rollupValues(o.values, values);\r\n }\r\n else {\r\n values = o.values;\r\n }\r\n dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid, uid: o.uid });\r\n s.columns.forEach(function (col) {\r\n switch (col.summaryOperation) {\r\n case 'first':\r\n o[col.columnId] = values[0][col.columnName];\r\n break;\r\n case 'last':\r\n o[col.columnId] = values[o.values.length - 1][col.columnName];\r\n break;\r\n case 'count':\r\n o[col.columnId] = values.length;\r\n break;\r\n case 'min':\r\n o[col.columnId] = d3.min(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'max':\r\n o[col.columnId] = d3.max(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'extent':\r\n o[col.columnId] = d3.extent(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'sum':\r\n o[col.columnId] = d3.sum(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'mean':\r\n o[col.columnId] = d3.mean(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'median':\r\n o[col.columnId] = d3.median(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'variance':\r\n o[col.columnId] = d3.variance(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n case 'deviation':\r\n o[col.columnId] = d3.deviation(values, function (d) {\r\n return d[col.columnName];\r\n });\r\n break;\r\n default:\r\n o[col.columnId] = values[0][col.columnName];\r\n break;\r\n }\r\n });\r\n processValues(o.values, sequence + 1, config, o.uid, dataIterator);\r\n });\r\n }\r\n else {\r\n obj.forEach(function (o) {\r\n o.sequence = sequence;\r\n dataIterator.push({ sequence: sequence, data: o, columns: s.columns, type: s.type, selected: false, parentUid: parentUid });\r\n });\r\n }\r\n};\r\n// Use a temp object for processing the data that we point back to\r\n// when done to trigger Angular change detection\r\nvar tempData = bezl.vars['data'];\r\nbezl.vars['dataIterator'] = [];\r\nprocessValues(tempData, 1, bezl.vars['config'], '', bezl.vars['dataIterator']);\r\nbezl.vars['data'] = tempData;\r\n// Apply sorts\r\nbezl.vars['config'].structure.forEach(function (s) {\r\n s.columns.forEach(function (c) {\r\n if (c.sort != '') {\r\n bezl.functions['sort']({ section: s, column: c, sequence: s.sequence, initial: true });\r\n }\r\n });\r\n});\r\n"
    },
    {
      "method": "sort",
      "code": "var tempData = bezl.vars['dataIterator'];\nvar section = parm.section;\nvar column = parm.column;\nvar sequence = parm.sequence;\nvar initial = parm.initial;\n\n\n// Set the column sort direction unless this is the initial sorting\nif (initial != false) {\n  if (!column.sort && (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent')) {\n    column.sort = 'descending';\n  } else if (!column.sort || column.sort == 'descending') {\n    column.sort = 'ascending';\n  } else if (column.sort == 'ascending') {\n    column.sort = 'descending';\n  }\n}\n\n// Also zap any previous sort indicators\nsection.columns.forEach(col => {\n  if (col != column) {\n    col.sort = '';\n  }\n});\n\n// First index all of the entries\nfor (var i = 0; i < tempData.length; i++) {\n  tempData[i].index = i;\n}\n\n// Next sort by sequence so we can clump together same-level data\ntempData.sort(function(a, b) { return a.sequence - b.sequence; });\n\n// Now locate the stop and start positions of the sequence level we are sorting\nvar start = tempData.findIndex(r => r.sequence == sequence);\nvar end = tempData.slice(start, tempData.length).findIndex(r => r.sequence != sequence);\nif (end == -1) {\n  end = tempData.length;\n}\n\n// Store the unsorted elements before and after our sequence level\nvar pre = tempData.slice(0, start);\npre.sort(function(a, b) { return a.index - b.index; });\nvar post = tempData.slice(end, tempData.length);\npost.sort(function(a, b) { return a.index - b.index; });\n\n// Now sort the sequence level\nvar sorted = tempData.slice(start, end).sort(function(a, b) {\n  if (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent') {\n    // Push the nulls to the bottom\n    if ((a.data[column.columnId] || a.data[column.columnName]) == null) {\n      return 1;\n    } else if ((b.data[column.columnId] || b.data[column.columnName]) == null) {\n      return -1;\n    }\n\n    if (column.sort == 'descending') {\n      var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\n      var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\n      return B - A;\n    } else {\n      var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\n      var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\n      return A - B;\n    }\n  } else {\n    var A = (a.data[column.columnId] || a.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\n    var B = (b.data[column.columnId] || b.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\n\n    if (column.sort == 'ascending') {\n      if (A < B) {\n          return -1;\n      }\n      if (A > B) {\n          return 1;\n      }\n    } else {\n      if (A > B) {\n          return -1;\n      }\n      if (A < B) {\n          return 1;\n      }\n    }\n\n    // names must be equal\n    return 0;\n  }\n});\n\n// Reconstruct the array.  If the sequence is greater than 1 then reverse\n// the sorted object so we can put them back under the parent last to first\nif (sequence == 1) {\n  tempData = pre.concat(sorted).concat(post);\n} else {\n  tempData = pre.concat(sorted.reverse()).concat(post);\n}\n\nvar moveElement = function (array, old_index, new_index) {\n  if (new_index >= array.length) {\n      var k = new_index - array.length;\n      while ((k--) + 1) {\n          array.push(undefined);\n      }\n  }\n  array.splice(new_index, 0, array.splice(old_index, 1)[0]);\n};\n\n// Now put the child records back inline with parents\ntempData.forEach(row => {\n  if (row.sequence >= sequence) {\n    var parent = tempData.find(t => t.uid == row.parentUid);\n    if (parent) {\n      moveElement(tempData, tempData.indexOf(row), tempData.indexOf(parent) + 1);\n    }\n  }\n});\n\nbezl.vars['dataIterator'] = tempData;",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "var tempData = bezl.vars['dataIterator'];\r\nvar section = parm.section;\r\nvar column = parm.column;\r\nvar sequence = parm.sequence;\r\nvar initial = parm.initial;\r\n// Set the column sort direction unless this is the initial sorting\r\nif (initial != false) {\r\n if (!column.sort && (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent')) {\r\n column.sort = 'descending';\r\n }\r\n else if (!column.sort || column.sort == 'descending') {\r\n column.sort = 'ascending';\r\n }\r\n else if (column.sort == 'ascending') {\r\n column.sort = 'descending';\r\n }\r\n}\r\n// Set the column sort direction\r\nif (!column.sort && (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent')) {\r\n column.sort = 'descending';\r\n}\r\nelse if (!column.sort || column.sort == 'descending') {\r\n column.sort = 'ascending';\r\n}\r\nelse if (column.sort == 'ascending') {\r\n column.sort = 'descending';\r\n}\r\n// Also zap any previous sort indicators\r\nsection.columns.forEach(function (col) {\r\n if (col != column) {\r\n col.sort = '';\r\n }\r\n});\r\nfor (var i = 0; i < tempData.length; i++) {\r\n tempData[i].index = i;\r\n}\r\n// Next sort by sequence so we can clump together same-level data\r\ntempData.sort(function (a, b) {\r\n return a.sequence - b.sequence;\r\n});\r\n// Now locate the stop and start positions of the sequence level we are sorting\r\nvar start = tempData.findIndex(function (r) { return r.sequence == sequence; });\r\nvar end = tempData.slice(start, tempData.length).findIndex(function (r) { return r.sequence != sequence; });\r\nif (end == -1) {\r\n end = tempData.length;\r\n}\r\n// Store the unsorted elements before and after our sequence level\r\nvar pre = tempData.slice(0, start);\r\npre.sort(function (a, b) {\r\n return a.index - b.index;\r\n});\r\nvar post = tempData.slice(end, tempData.length);\r\npost.sort(function (a, b) {\r\n return a.index - b.index;\r\n});\r\n// Now sort the sequence level\r\nvar sorted = tempData.slice(start, end).sort(function (a, b) {\r\n if (column.formatter.type == 'currency' || column.formatter.type == 'number' || column.formatter.type == 'percent') {\r\n // Push the nulls to the bottom\r\n if ((a.data[column.columnId] || a.data[column.columnName]) == null) {\r\n return 1;\r\n }\r\n else if ((b.data[column.columnId] || b.data[column.columnName]) == null) {\r\n return -1;\r\n }\r\n if (column.sort == 'descending') {\r\n var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\r\n var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\r\n return B - A;\r\n }\r\n else {\r\n var A = (a.data[column.columnId] || a.data[column.columnName]) != null ? (a.data[column.columnId] || a.data[column.columnName]) : Number.MAX_VALUE;\r\n var B = (b.data[column.columnId] || b.data[column.columnName]) != null ? (b.data[column.columnId] || b.data[column.columnName]) : Number.MAX_VALUE;\r\n return A - B;\r\n }\r\n }\r\n else {\r\n var A = (a.data[column.columnId] || a.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\r\n var B = (b.data[column.columnId] || b.data[column.columnName] || '').toString().toUpperCase(); // ignore upper and lowercase\r\n if (column.sort == 'ascending') {\r\n if (A < B) {\r\n return -1;\r\n }\r\n if (A > B) {\r\n return 1;\r\n }\r\n }\r\n else {\r\n if (A > B) {\r\n return -1;\r\n }\r\n if (A < B) {\r\n return 1;\r\n }\r\n }\r\n // names must be equal\r\n return 0;\r\n }\r\n});\r\n// Reconstruct the array. If the sequence is greater than 1 then reverse\r\n// the sorted object so we can put them back under the parent last to first\r\nif (sequence == 1) {\r\n tempData = pre.concat(sorted).concat(post);\r\n}\r\nelse {\r\n tempData = pre.concat(sorted.reverse()).concat(post);\r\n}\r\nvar moveElement = function (array, old_index, new_index) {\r\n if (new_index >= array.length) {\r\n var k = new_index - array.length;\r\n while ((k--) + 1) {\r\n array.push(undefined);\r\n }\r\n }\r\n array.splice(new_index, 0, array.splice(old_index, 1)[0]);\r\n};\r\n// Now put the child records back inline with parents\r\ntempData.forEach(function (row) {\r\n if (row.sequence >= sequence) {\r\n var parent = tempData.find(function (t) { return t.uid == row.parentUid; });\r\n if (parent) {\r\n moveElement(tempData, tempData.indexOf(row), tempData.indexOf(parent) + 1);\r\n }\r\n }\r\n});\r\nbezl.vars['dataIterator'] = tempData;\r\n"
    },
    {
      "method": "selectRow",
      "code": "var row = parm;\nvar selected = !row.selected;\nrow.selected = selected;\n\nvar keepGoing = true;\nvar i = bezl.vars['dataIterator'].indexOf(row) + 1;\nwhile (keepGoing) {\n  if (bezl.vars['dataIterator'][i].sequence == row.sequence + 1) {\n    bezl.vars['dataIterator'][i].show = selected;\n  } else if (bezl.vars['dataIterator'][i].sequence <= row.sequence + 1) {\n    keepGoing = false;\n  }\n  i++;\n}",
      "declares": [
        "$",
        "parm",
        "bezl",
        "dataResp",
        "require",
        "FusionCharts"
      ],
      "compiled": "var row = parm;\r\nvar selected = !row.selected;\r\nrow.selected = selected;\r\nvar keepGoing = true;\r\nvar i = bezl.vars['dataIterator'].indexOf(row) + 1;\r\nwhile (keepGoing) {\r\n if (bezl.vars['dataIterator'][i].sequence == row.sequence + 1) {\r\n bezl.vars['dataIterator'][i].show = selected;\r\n }\r\n else if (bezl.vars['dataIterator'][i].sequence <= row.sequence + 1) {\r\n keepGoing = false;\r\n }\r\n i++;\r\n}\r\n"
    }
  ],
  "data": ""
}